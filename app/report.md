## Веб-приложение

### Код

#### Структура

- `client/` - клиент на Streamlit
    - `main.py` - код клиента
- `server/` - сервер на FastAPI
    - `main.py` - код endpoint'ов сервера
    - `tracking.py` - реализация непосредственно трекинга и список доступных моделей
    - `video.py` - функции, связанные с операциями над видео и картинками
    - `config/botsort.yaml` - конфигурация трекера BoT-SORT
    - `models/` - веса доступных детекторов

В каждой из папок также есть свой Dockerfile и файл `requirements.txt`.

#### Линтеры

Для форматирования кода я пользовался библиотекой `black`, поставив параметр `--line-length 79`, чтобы соответствовать максимальной длине строки из PEP8. Мой код проходит проверки `pycodestyle`, `flake8` и `pylint`, за исключением пары варнингов от `flake8`, которые конфликтуют с `black` и с самим PEP8 (код E203, подробнее [здесь](https://black.readthedocs.io/en/stable/guides/using_black_with_other_tools.html#e203)). Я решил это не исправлять, т. к. мне удобнее следовать формату `black` и он даже указывался как рекомендованный автоформаттер для годовых проектов.

### Функционал

#### Замена задачи

Я решил не реализовывать для этой задачи сервис с дообучением, т.к. это было бы непрактично из-за размеров датасетов и времени, которое занимает обучение, особенно если у пользователя нет GPU. Вместо этого сервис делает инференс обученной модели, а затем предоставляет интерфейс, где отображаются все найденные игроки и есть различные операции для визуализации результатов трекинга.

Замена задачи была согласована с куратором.

#### Инструкция для пользователя

Инструкция для пользователя с описанием установки, интерфейса клиента и картинками описана в файле [README.md](../README.md). Далее в этом файле я буду скорее описывать внутреннюю работу сервера и его API.

#### Получение списка доступных моделей

Для получения списка доступных моделей при запуске клиент вызывает эндпоинт сервера `/get_models`, не принимающий на вход никаких параметров. Сервер возвращает список доступных детекторов и трекеров. У каждого есть короткое название, которое сам клиент потом использует в запросах к серверу (`slug`), и более красивое название, которое отображается в интерфейсе для пользователя (`ui_name`).

#### Инференс

Для инференса с выбранным детектором и трекером сервер предоставляет эндпоинт `/infer?detector={detector}&tracker={tracker}`, принимающий на вход видеофайл через `fastapi.UploadFile`. Он сохраняется в память и на нём производится трекинг средствами библиотеки `ultralytics`. Сервер сохраняет в память необходимые результаты (путь к загруженному видео на сервере, bbox'ы и id найденных игроков для каждого кадра), а также генерирует и отправляет клиенту следующую информацию:

1. список id найденных игроков,
2. диапазоны времени, когда эти игроки были видны на видео,
3. обрезанное изображение первой детекции каждого игрока,
4. видео, на котором игроки выделены рамками и подписаны их id.

Пункты 1 и 2 отправляются через HTTP хедеры, а пункты 3 и 4 архивируются и отправляются в виде zip-файла, который клиент потом распаковывает.

Для генерации видео я не пользуюсь встроенными средствами библиотеки `ultralytics`, т.к. они недостаточно кастомизируемы для моей задачи. Вместо этого я вручную итерируюсь по кадрам видео с помощью библиотеки `moviepy` и рисую рамки с помощью библиотеки `bbox-visualizer`.

#### Генерация видео

В интерфейсе клиента пользователь может поменять для каждого найденного игрока следующие настройки:

- выделять ли его на видео (по умолчанию: да),
- кастомную подпись на видео (по умолчанию: "id<номер>").

Чтобы сгенерировать видео с новыми настройками, клиент вызывает эндпоинт `/make_video`, передавая настройки в теле запроса. Сервер возвращает сгенерированное видео в виде файла.

#### Генерация сфокусированного видео

Пользователь может для каждого найденного игрока сгенерировать видео, которое показывает только перемещения этого конкретного игрока. Это делается эндпоинтом `/make_focused_video?player_id={player_id}`.

Чтобы сделать такое видео, каждый кадр изначального видео, где присутствует игрок, обрезается по границам его bbox'а. Итоговое видео имеет ширину, равную максимальной ширине среди bbox'ов, и высоту, равную максимальной высоте среди bbox'ов. Так как большинство bbox'ов окажутся меньше, чем эта максимальная ширина и высота, то для большинства кадров в итоговое видео также включается область вокруг bbox'а, оставляя bbox по возможности в центре кадра.

#### Логгирование

В клиенте и сервере настроено логгирование в папку `logs` с ротацией каждый день и удалением старых логов через 7 дней. Это реализовано через встроенную библиотеку `logging`.
